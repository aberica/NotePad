Python Template Code : SW﻿ Certificate 사이트 -> 자료실 -> 204번 글을 참고하시기 바랍니다.

 

 

[문제 설명]

N개의 도시가 주어진다. 각 도시는 0부터 N-1까지 ID값을 가진다.

도시를 연결하는 단방향 도로가 추가될 때, 해당 도로의 ID와 소요 시간이 주어진다.

전쟁 중인 상황으로 적의 군대는 항상 최단 경로로 이동한다.

적군의 출발지와 목적지가 주어졌을 때, 하나의 도로를 파괴해서 적군의 이동을 지연 시킬 수 있는 최대 시간을 구하고자 한다.

[Fig. 1]은 5개의 도시가 주어진 예이다.



                                     [Fig. 1]

초기에, 0번 도시에서 4번 도시로 가는데 필요한 최소 시간은 120이다.
(0 --(time:50)--> 1 --(time:60)--> 3 --(time:10)--> 4)

2000 도로를 파괴하면, 0번 도시에서 4번 도시로 가는데 필요한 최소 시간은 140이다. 이 것이 적군의 이동이 가장 늦어지는 경우이다.
따라서 지연 시킬 수 있는 최대 시간은 20이다.
(0 --(time:30)--> 2 --(time:40)--> 1 --(time:60)--> 3 --(time:10)--> 4)

 

아래 API 설명을 참조하여 각 함수를 구현하라.

※ 아래 함수 signature는 C/C++에 대한 것으로 다른 언어에 대해서는 제공되는 Main과 User Code를 참고하라.

 

아래는 User Code 부분에 작성해야 하는 API 의 설명이다.

void init(int N, int K, int mId[], int sCity[], int eCity[], int mTime[])

각 테스트 케이스의 처음에 호출된다.

N개의 도시가 주어진다. 각 도시는 0부터 N-1까지 ID값을 가진다.

K개의 도로 정보가 주어진다. 각 도로의 ID, 출발 도시와 도착 도시, 그리고 소요 시간이 주어진다.

단방향 도로이기 때문에 출발 도시에서 도착 도시로만 갈 수 있다.

출발 도시와 도착 도시의 순서쌍이 동일한 도로는 없다.

출발 도시와 도착 도시가 서로 같은 경우는 없다.

도로 ID가 서로 같은 경우는 없다.

 

Parameters

N: 도시의 개수 ( 5 ≤ N ≤ 1,000 )

K: 도로의 개수 ( 7 ≤ K ≤ 5,000 )

 

(0 ≤ i ＜ K)인 모든 i에 대해,

mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )

sCity[i]: 도로 i의 출발 도시 ( 0 ≤ sCity[i] < N )

eCity[i]: 도로 i의 도착 도시 ( 0 ≤ eCity[i] < N )

mTime[i]: 도로 i의 소요 시간 ( 1 ≤ mTime[i] ≤ 1,000 )

void add(int mId, int sCity, int eCity, int mTime)

출발 도시가 sCity이고, 도착 도시가 eCity이고, 소요 시간이 mTime인 mId 도로를 추가한다.

단방향 도로이기 때문에 출발 도시에서 도착 도시로만 갈 수 있다.

init()에 없던 새로운 도시는 주어지지 않는다.

sCity에서 eCity로 가는 도로가 이미 존재하는 경우는 없다.

sCity와 eCity가 서로 같은 경우는 없다.

mId 값으로 이미 존재하는 도로의 ID가 주어지는 경우는 없다.

 

Parameters

mId: 도로의 ID ( 1 ≤ mId ≤ 1,000,000,000 )

sCity: 도로의 출발 도시 ( 0 ≤ sCity < N )

eCity: 도로의 도착 도시 ( 0 ≤ eCity < N )

mTime: 도로의 소요 시간 ( 1 ≤ mTime ≤ 1,000 )

void remove(int mId)

mId 도로를 제거한다.

존재하지 않는 도로의 ID가 주어지는 경우는 없다.

 

Parameters

mId: 도로의 ID ( 1 ≤ mId ≤ 1,000,000,000 )

int calculate(int sCity, int eCity)

적군이 sCity에서 eCity까지 최단 경로로 이동할 때, 하나의 도로를 파괴해서 지연 시킬 수 있는 최대 시간을 반환한다.

sCity와 eCity가 서로 같은 경우는 없다.

 

Parameters

sCity: 출발 도시 ( 0 ≤ sCity < N )

eCity: 도착 도시 ( 0 ≤ eCity < N )

 

Returns

최대 지연 시간을 반환한다.

도로 파괴 이전 또는 도로 파괴 이후에 목적지까지 이동이 불가능하다면, -1을 반환한다.

 

[예제]

아래의 [Table 1]과 같이 요청이 되는 경우를 살펴보자.

Order

Function

return

Figure

1

init(5, 7, {2000,1000,4000,3000,7000,5000,6000}, {0,1,3,3,2,0,2}, {1,3,4,1,1,2,4}, {50,60,10,20,40,30,30})

 

Fig. 2

2

calculate(0, 4)

60

Fig. 3

3

remove(6000)

 

Fig. 4

4

calculate(1, 4)

-1

 

5

add(8000, 1, 4, 80)

 

Fig. 5

6

calculate(0, 4)

20

Fig. 6

                                                                                   [Table 1]

(순서 1) 5개의 도시와 7개의 도로 정보가 주어진다. 함수 호출의 결과는 [Fig. 2]와 같다.



                                     [Fig. 2]

(순서 2) 적군이 0번 도시에서 4번 도시로 이동할 때, 하나의 도로를 파괴해서 지연 시킬 수 있는 최대 시간을 계산한다.
[Fig. 3]과 같이 6000 도로 혹은 5000 도로를 파괴하는 것이 지연 시간을 가장 크게 할 수 있다. 최대 지연 시간으로 60을 반환한다.



                                     [Fig. 3]

(순서 3) 6000 도로를 제거한다. 함수 호출의 결과는 [Fig. 4]와 같다.



                                     [Fig. 4]

(순서 4) 적군이 1번 도시에서 4번 도시로 이동할 때, 하나의 도로를 파괴해서 지연 시킬 수 있는 최대 시간을 계산한다.
1000 도로 혹은 4000 도로를 파괴하면 4번 도시로 이동이 불가능해지기 때문에 -1을 반환한다.

(순서 5) 1번 도시에서 4번 도시로 갈 수 있는 8000 도로가 추가된다. 도로의 소요 시간은 80이다. 함수 호출의 결과는 [Fig. 5]와 같다.



                                     [Fig. 5]

(순서 6) 적군이 0번 도시에서 4번 도시로 이동할 때, 하나의 도로를 파괴해서 지연 시킬 수 있는 최대 시간을 계산한다.
[Fig. 6]과 같이 2000 도로를 파괴하는 것이 지연 시간을 가장 크게 할 수 있다. 최대 지연 시간으로 20을 반환한다.



                                     [Fig. 6]

 

[제약사항]

1. 각 테스트 케이스 시작 시 init() 함수가 호출된다.

2. 각 테스트 케이스에서 add() 함수의 호출 횟수는 1,500 이하이다.

3. 각 테스트 케이스에서 remove() 함수의 호출 횟수는 500 이하이다.

4. 각 테스트 케이스에서 calculate() 함수의 호출 횟수는 200 이하이다.

 

[입출력]

입출력은 제공되는 Main 부분의 코드에서 처리하므로 User Code 부분의 코드에서는 별도로 입출력을 처리하지 않는다.

Sample input 에 대한 정답 출력 결과는 “#TC번호 결과” 의 포맷으로 보여지며 결과가 100 일 경우 정답, 0 일 경우 오답을 의미한다.
